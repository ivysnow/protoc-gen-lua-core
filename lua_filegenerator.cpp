#include "lua_filegenerator.h"
#include <vector>
#include <fmt/format.h>

using namespace std;
using namespace google::protobuf;
using namespace google::protobuf::compiler;
using namespace google::protobuf::io;
using namespace starlight::protobuf::compiler::lua;

static vector<string> split(const char* str, const char* sep)
{
	vector<string> results;

	{
		size_t count = 0;
		size_t lpos = 0;
		while (auto ip = strpbrk(str + lpos, sep))
		{
			auto rpos = static_cast<size_t>(ip - str);
			++count;
			lpos = rpos + 1;
		}
		results.reserve(count + 1);
	}
	{
		size_t lpos = 0;
		while (auto ip = strpbrk(str + lpos, sep))
		{
			auto rpos = static_cast<size_t>(ip - str);
			results.push_back({ &str[lpos], rpos - lpos });
			lpos = rpos + 1;
		}
		results.push_back({ &str[lpos] });
	}

	return results;
}

static string GetBaseName(const string& filename)
{
	return fmt::format("{}_pb", filename.substr(0, filename.find_first_of('.')));
}

static string GetModuleName(const string& filename)
{
	return fmt::format("{}_pb", filename.substr(filename.find_last_of('/') + 1, filename.find_first_of('.') - filename.find_last_of('/') - 1));
}

static string GetFieldDefaultValue(const FieldDescriptor* field)
{
	switch (field->cpp_type())
	{
	case FieldDescriptor::CPPTYPE_INT32:
		return fmt::format("{}", field->default_value_int32());

	case FieldDescriptor::CPPTYPE_INT64:
		return fmt::format("{}", field->default_value_int64());

	case FieldDescriptor::CPPTYPE_UINT32:
		return fmt::format("{}", field->default_value_uint32());

	case FieldDescriptor::CPPTYPE_UINT64:
		return fmt::format("{}", field->default_value_uint64());

	case FieldDescriptor::CPPTYPE_DOUBLE:
		return fmt::format("{}", field->default_value_double());

	case FieldDescriptor::CPPTYPE_FLOAT:
		return fmt::format("{}", field->default_value_float());

	case FieldDescriptor::CPPTYPE_BOOL:
		return fmt::format("{}", field->default_value_bool());

	case FieldDescriptor::CPPTYPE_ENUM:
		return fmt::format("{}", field->default_value_enum()->number());

	case FieldDescriptor::CPPTYPE_STRING:
		return fmt::format("'{}'", field->default_value_string());

	case FieldDescriptor::CPPTYPE_MESSAGE:
	default:
		return "nil";
	}
}

FileGenerator::FileGenerator(const FileDescriptor* file, GeneratorContext* context, Options options)
	: m_options(options)
	, m_file{ file }
	, m_output{ context->Open(fmt::format("{}.lua", GetBaseName(m_file->name()))) }
	, m_printer{ m_output.get(), '$' }
{}

void FileGenerator::Generate()
{
	m_printer.Print(
		"-- Generated by protoc-gen-lua-core.  DO NOT EDIT!\n"
	);

	GenerateImport();
	GenerateExport();
	GenerateDescriptors();
	GenerateVariables();
	GenerateReturn();
}

void FileGenerator::GenerateImport()
{
	m_printer.Print(
		"local protobuf = require 'protobuf/protobuf';\n"
	);
	for (auto i = 0; i < m_file->dependency_count(); ++i)
	{
		auto dependency = m_file->dependency(i);

		ParseSymbolNames(dependency, GetModuleName(dependency->name()));
		GenerateDependency(dependency);
	}
}

void FileGenerator::GenerateDependency(const FileDescriptor* dependency)
{
	if (!m_options.unity.empty())
	{
		m_printer.Print(
			"require '$unity$/$baseName$';\n",
			"unity", m_options.unity,
			"baseName", GetBaseName(dependency->name())
		);
	}
	else
	{
		m_printer.Print(
			"local $moduleName$ = require '$baseName$';\n",
			"moduleName", GetModuleName(dependency->name()),
			"baseName", GetBaseName(dependency->name())
		);
	}
}

void FileGenerator::GenerateExport()
{
	if (!m_options.unity.empty())
	{
		ParseSymbolNames(m_file, GetModuleName(m_file->name()));
	}
	else
	{
		ParseSymbolNames(m_file);
	}

	m_printer.Print("\n");
	if (!m_options.unity.empty())
	{
		m_printer.Print(
			"$moduleName$ = {};\n"
			"$moduleName$.Enums = {};\n"
			"$moduleName$.Messages = {};\n",
			"moduleName", GetModuleName(m_file->name())
		);
	}
	else
	{
		m_printer.Print(
			"module '$moduleName$';\n"
			"\n"
			"Enums = {};\n"
			"Messages = {};\n",
			"moduleName", GetModuleName(m_file->name())
		);
	}
}

void FileGenerator::GenerateDescriptors()
{
	if (m_file->enum_type_count() || m_file->message_type_count())
	{
		m_printer.Print("\n");
	}
	for (auto i = 0; i < m_file->enum_type_count(); ++i)
	{
		GenerateEnumDescriptor(m_file->enum_type(i));
	}

	for (auto i = 0; i < m_file->message_type_count(); ++i)
	{
		GenerateMessageDescriptor(m_file->message_type(i));
	}
}

void FileGenerator::GenerateEnumDescriptor(const EnumDescriptor* enumType)
{
	auto varName = ResolveVarName(enumType->full_name());

	m_printer.Print(
		"$varName$ = {};\n"
		"$varName$.Values = {};\n",
		"varName", varName
	);
	for (auto i = 0; i < enumType->value_count(); ++i)
	{
		auto value = enumType->value(i);

		m_printer.Print(
			"$varName$.Values.$valueName$ = protobuf.EnumValueDescriptor();\n"
			"$varName$.Values.$valueName$.name = '$valueName$';\n"
			"$varName$.Values.$valueName$.index = $index$;\n"
			"$varName$.Values.$valueName$.number = $number$;\n",
			"varName", varName,
			"valueName", value->name(),
			"index", fmt::format("{}", value->index()),
			"number", fmt::format("{}", value->number())
		);
	}
	m_printer.Print(
		"$varName$.Descriptor = protobuf.EnumDescriptor();\n"
		"$varName$.Descriptor.name = '$enumName$';\n"
		"$varName$.Descriptor.full_name = '$fullName$';\n"
		"$varName$.Descriptor.values = {",
		"varName", varName,
		"enumName", enumType->name(),
		"fullName", ResolveName(enumType->full_name())
	);
	for (auto i = 0; i < enumType->value_count(); ++i)
	{
		auto value = enumType->value(i);

		m_printer.Print(
			"$separator$$varName$.Values.$valueName$",
			"separator", i == 0 ? "" : ",",
			"varName", varName,
			"valueName", value->name()
		);
	}
	m_printer.Print("};\n");
}

void FileGenerator::GenerateMessageDescriptor(const Descriptor* messageType)
{
	auto varName = ResolveVarName(messageType->full_name());
	auto fullName = ResolveName(messageType->full_name());

	m_printer.Print(
		"$varName$ = {};\n"
		"$varName$.Enums = {};\n"
		"$varName$.Messages = {};\n"
		"$varName$.Fields = {};\n",
		"varName", varName
	);
	for (auto i = 0; i < messageType->enum_type_count(); ++i)
	{
		GenerateEnumDescriptor(messageType->enum_type(i));
	}
	for (auto i = 0; i < messageType->nested_type_count(); ++i)
	{
		GenerateMessageDescriptor(messageType->nested_type(i));
	}
	for (auto i = 0; i < messageType->field_count(); ++i)
	{
		auto field = messageType->field(i);

		m_printer.Print(
			"$varName$.Fields.$fieldName$ = protobuf.FieldDescriptor();\n"
			"$varName$.Fields.$fieldName$.name = '$fieldName$';\n"
			"$varName$.Fields.$fieldName$.full_name = '$fullName$.$fieldName$';\n"
			"$varName$.Fields.$fieldName$.number = $number$;\n"
			"$varName$.Fields.$fieldName$.index = $index$;\n"
			"$varName$.Fields.$fieldName$.label = $label$;\n",
			"varName", varName,
			"fieldName", field->name(),
			"fullName", fullName,
			"number", fmt::format("{}", field->number()),
			"index", fmt::format("{}", field->index()),
			"label", fmt::format("{}", field->label())
		);
		switch (field->cpp_type())
		{
		case FieldDescriptor::CPPTYPE_INT32:
		case FieldDescriptor::CPPTYPE_INT64:
		case FieldDescriptor::CPPTYPE_UINT32:
		case FieldDescriptor::CPPTYPE_UINT64:
		case FieldDescriptor::CPPTYPE_DOUBLE:
		case FieldDescriptor::CPPTYPE_FLOAT:
		case FieldDescriptor::CPPTYPE_BOOL:
		case FieldDescriptor::CPPTYPE_ENUM:
		{
			m_printer.Print(
				"$varName$.Fields.$fieldName$.has_options = $has_options$;\n"
				"$varName$.Fields.$fieldName$.GetOptions = function () return { packed = $packed$ }; end;\n",
				"varName", varName,
				"fieldName", field->name(),
				"has_options", field->label() == FieldDescriptor::LABEL_REPEATED ? "true" : "false",
				"packed", field->label() == FieldDescriptor::LABEL_REPEATED ? "true" : "false"
			);
			break;
		}

		default:
			break;
		}
		m_printer.Print(
			"$varName$.Fields.$fieldName$.has_default_value = $has_default_value$;\n"
			"$varName$.Fields.$fieldName$.default_value = $default_value$;\n",
			"varName", varName,
			"fieldName", field->name(),
			"has_default_value", field->has_default_value() ? "true" : "false",
			"default_value", GetFieldDefaultValue(field)
		);
		if (field->type() == FieldDescriptor::TYPE_MESSAGE)
		{
			m_printer.Print(
				"$varName$.Fields.$fieldName$.message_type = $field_type$.Descriptor;\n",
				"varName", varName,
				"fieldName", field->name(),
				"field_type", ResolveVarName(field->message_type()->full_name())
			);
		}
		else if (field->type() == FieldDescriptor::TYPE_ENUM)
		{
			m_printer.Print(
				"$varName$.Fields.$fieldName$.enum_type = $field_type$.Descriptor;\n",
				"varName", varName,
				"fieldName", field->name(),
				"field_type", ResolveVarName(field->enum_type()->full_name())
			);
		}
		m_printer.Print(
			"$varName$.Fields.$fieldName$.type = $type$;\n"
			"$varName$.Fields.$fieldName$.cpp_type = $cpp_type$;\n",
			"varName", varName,
			"fieldName", field->name(),
			"type", fmt::format("{}", field->type()),
			"cpp_type", fmt::format("{}", field->cpp_type())
		);
	}
	m_printer.Print(
		"$varName$.Descriptor = protobuf.Descriptor();\n"
		"$varName$.Descriptor.name = '$name$';\n"
		"$varName$.Descriptor.full_name = '$fullName$';\n"
		"$varName$.Descriptor.nested_types = {",
		"varName", varName,
		"name", messageType->name(),
		"fullName", fullName
	);
	for (auto i = 0; i < messageType->nested_type_count(); ++i)
	{
		auto value = messageType->nested_type(i);

		m_printer.Print(
			"$separator$$varName$.Messages.$name$.Descriptor",
			"separator", i == 0 ? "" : ",",
			"varName", varName,
			"name", value->name()
		);
	}
	m_printer.Print("};\n"
		"$varName$.Descriptor.enum_types = {",
		"varName", varName
	);
	for (auto i = 0; i < messageType->enum_type_count(); ++i)
	{
		auto value = messageType->enum_type(i);

		m_printer.Print(
			"$separator$$varName$.Enums.$name$.Descriptor",
			"separator", i == 0 ? "" : ",",
			"varName", varName,
			"name", value->name()
		);
	}
	m_printer.Print("};\n"
		"$varName$.Descriptor.fields = {",
		"varName", varName
	);
	for (auto i = 0; i < messageType->field_count(); ++i)
	{
		auto value = messageType->field(i);

		m_printer.Print(
			"$separator$$varName$.Fields.$name$",
			"separator", i == 0 ? "" : ",",
			"varName", varName,
			"name", value->name()
		);
	}
	m_printer.Print("};\n"
		"$varName$.Descriptor.is_extendable = $is_extendable$;\n"
		"$varName$.Descriptor.extensions = {",
		"varName", varName,
		"is_extendable", "false"
	);
	// TODO
	m_printer.Print("};\n");
}

void FileGenerator::GenerateVariables()
{
	if (m_file->enum_type_count() || m_file->message_type_count())
	{
		m_printer.Print("\n");
	}
	for (auto i = 0; i < m_file->enum_type_count(); ++i)
	{
		GenerateEnumVariables(m_file->enum_type(i));
	}

	for (auto i = 0; i < m_file->message_type_count(); ++i)
	{
		GenerateMessageVariables(m_file->message_type(i));
	}
}

void FileGenerator::GenerateEnumVariables(const EnumDescriptor* enumType)
{
	for (auto i = 0; i < enumType->value_count(); ++i)
	{
		auto value = enumType->value(i);

		if (!enumType->containing_type())
		{
			if (!m_options.unity.empty())
			{
				m_printer.Print(
					"$moduleName$.$valueName$ = $number$;\n",
					"moduleName", GetModuleName(enumType->file()->name()),
					"valueName", value->name(),
					"number", fmt::format("{}", value->number())
				);
			}
			else
			{
				m_printer.Print(
					"$valueName$ = $number$;\n",
					"valueName", value->name(),
					"number", fmt::format("{}", value->number())
				);
			}
		}
		else
		{
			if (!m_options.unity.empty())
			{
				m_printer.Print(
					"$moduleName$.$container$.$valueName$ = $number$;\n",
					"moduleName", GetModuleName(enumType->file()->name()),
					"container", ResolveName(enumType->containing_type()->full_name()).substr(1),
					"valueName", value->name(),
					"number", fmt::format("{}", value->number())
				);
			}
			else
			{
				m_printer.Print(
					"$container$.$valueName$ = $number$;\n",
					"container", ResolveName(enumType->containing_type()->full_name()).substr(1),
					"valueName", value->name(),
					"number", fmt::format("{}", value->number())
				);
			}
		}
	}
}

void FileGenerator::GenerateMessageVariables(const Descriptor* messageType)
{
	if (!m_options.unity.empty())
	{
		m_printer.Print(
			"$moduleName$.$name$ = protobuf.Message($varName$.Descriptor);\n",
			"moduleName", GetModuleName(messageType->file()->name()),
			"name", ResolveName(messageType->full_name()).substr(1),
			"varName", ResolveVarName(messageType->full_name())
		);
	}
	else
	{
		m_printer.Print(
			"$name$ = protobuf.Message($varName$.Descriptor);\n",
			"name", ResolveName(messageType->full_name()).substr(1),
			"varName", ResolveVarName(messageType->full_name())
		);
	}
	for (auto i = 0; i < messageType->enum_type_count(); ++i)
	{
		GenerateEnumVariables(messageType->enum_type(i));
	}
	for (auto i = 0; i < messageType->nested_type_count(); ++i)
	{
		GenerateMessageVariables(messageType->nested_type(i));
	}
}

void FileGenerator::GenerateReturn()
{
	if (!m_options.unity.empty())
	{
		m_printer.Print("\n");
		m_printer.Print(
			"return $moduleName$;\n",
			"moduleName", GetModuleName(m_file->name())
		);
	}
}

void FileGenerator::ParseSymbolNames(const FileDescriptor* file, const string& moduleName)
{
	for (auto i = 0; i < file->enum_type_count(); ++i)
	{
		ParseEnumName(file->enum_type(i), moduleName);
	}
	for (auto i = 0; i < file->message_type_count(); ++i)
	{
		ParseMessageName(file->message_type(i), moduleName);
	}
}

void FileGenerator::ParseEnumName(const EnumDescriptor* enumType, const string& moduleName)
{
	ParseName(enumType->full_name(), enumType->full_name().substr(enumType->file()->package().size()), moduleName, "Enums");
}

void FileGenerator::ParseMessageName(const Descriptor* messageType, const string& moduleName)
{
	for (auto i = 0; i < messageType->enum_type_count(); ++i)
	{
		ParseEnumName(messageType->enum_type(i), moduleName);
	}
	for (auto i = 0; i < messageType->nested_type_count(); ++i)
	{
		ParseMessageName(messageType->nested_type(i), moduleName);
	}

	ParseName(messageType->full_name(), messageType->full_name().substr(messageType->file()->package().size()), moduleName, "Messages");
}

void FileGenerator::ParseName(const string& fullName, const string& name, const string& moduleName, const string& lastSeperate)
{
	auto shortName = fmt::format("{}{}", (!name.empty() && name[0] != '.' ? "." : ""), name);
	auto varName = ""s;

	auto names = split(name.c_str(), ".");

	if (!moduleName.empty())
	{
		varName = fmt::format("{}{}.", varName, moduleName);
	}

	for (size_t i = 0; i < names.size(); ++i)
	{
		if (names[i].empty())
		{
			continue;
		}

		if (i == names.size() - 1)
		{
			varName = fmt::format("{}{}.{}.", varName, lastSeperate, names[i]);
		}
		else
		{
			varName = fmt::format("{}{}.{}.", varName, "Messages", names[i]);
		}
	}

	if (varName[varName.size() - 1] == '.')
	{
		varName.resize(varName.size() - 1);
	}

	m_nameMap[fullName] = make_tuple<>(shortName, varName);
}

const string& FileGenerator::ResolveName(const string& fullName) const
{
	static string s_error = "<error>";

	auto it = m_nameMap.find(fullName);

	if (it == m_nameMap.end())
		return s_error;

	return get<0>(it->second);
}

const string& FileGenerator::ResolveVarName(const string& fullName) const
{
	static string s_error = "<error>";

	auto it = m_nameMap.find(fullName);

	if (it == m_nameMap.end())
		return s_error;

	return get<1>(it->second);
}
